{
    "nodes": {
        "os_api_basics": {
            "type": "task",
            "title": "LibXR · 系统层 · 操作系统 API 入门",
            "subtitle": "统一线程 / 同步原语 / 定时器与异步任务，在裸机、RTOS 和 Linux 上保持同一套用法。",
            "tags": [
                "LibXR",
                "系统层",
                "操作系统",
                "线程",
                "同步"
            ],
            "tasks": [
                {
                    "id": "os_api_intro",
                    "title": "系统层概览：Thread / Semaphore / Mutex / Timer / Async 各管什么",
                    "desc": "【本任务目标】\n- 搞清楚：LibXR 里说的“系统层”覆盖哪些能力，以及它和具体操作系统（裸机、RTOS、Linux）的关系。\n- 建立一个概念：以后看到 Thread / Semaphore / Mutex / Timer / Async 这些名字，优先想到的是 LibXR 的统一抽象，而不是某个特定 RTOS 的 API。\n- 知道每一类能力应该去哪些文档里查细节。\n\n【系统层在整套体系里的位置】\n- 下层：是真正运行代码的环境，比如：\n  - 裸机（没有操作系统，自己写调度循环）。\n  - 各种 RTOS（FreeRTOS、ThreadX 等）。\n  - Linux 等通用操作系统。\n- 上层：是 LibXR 提供的一层统一接口：\n  - LibXR::Thread   —— 统一的线程 / 任务抽象；\n  - LibXR::Semaphore—— 信号量（等事件用的计数器）；\n  - LibXR::Mutex    —— 互斥锁（保护共享资源）；\n  - LibXR::Timer    —— 定时器（周期/延时调度逻辑）；\n  - LibXR::Async    —— 异步任务（在部分平台上可用）。\n- 你的业务代码只和这一层打交道：\n  - 在 STM32 + FreeRTOS 上，它最终会落到 FreeRTOS 的 API；\n  - 在 Linux 上，同一套调用会落到 pthread 或系统调用；\n  - 但你不用为每个平台分别写一版线程/互斥/定时器逻辑。\n\n【几个核心模块的直觉印象】\n- Thread（线程）：开新执行路径，比如把串口接收、传感器采样、控制算法拆开；\n- Semaphore（信号量）：等事件用的计数器，典型是“等某个 I/O 完成”；\n- Mutex（互斥锁）：保护共享资源，避免多个线程同时改同一块数据；\n- Timer（定时器）：让某段逻辑按固定周期被调度，而不是在 while(1) 里自己算时间；\n- Async（异步任务）：把“完成后的处理”挂到事件循环里，不在当前调用栈里阻塞。\n\n【文档入口】\n- LibXR 系统层相关文档（按模块名找 Thread / Semaphore / Mutex / Timer / Async）。\n- C++ API 参考：https://jiu-xiao.github.io/libxr/ ，遇到不确定的类型时按类名搜索即可。\n\n【完成标准】\n- 你能用自己的话解释：LibXR 的“系统层”是跨平台统一线程 / 同步 / 定时器 / 异步，不是某个 RTOS 专属 API。\n- 你知道：遇到 Thread / Semaphore / Mutex / Timer / Async 不确定用法时，大致去哪个文档、哪个 API 页面查。",
                    "link": "",
                    "estimateMinutes": 20
                }
            ]
        }
    }
}