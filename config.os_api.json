{
    "nodes": {
        "os_api_basics": {
            "type": "task",
            "title": "LibXR · 系统层 · 操作系统 API 入门",
            "subtitle": "统一线程 / 同步原语 / 定时器与异步任务，在裸机、RTOS 和 Linux 上保持同一套用法。",
            "tags": [
                "LibXR",
                "系统层",
                "操作系统",
                "线程",
                "同步"
            ],
            "tasks": [
                {
                    "id": "os_api_intro",
                    "title": "运行环境入门：裸机 / RTOS / Linux 是啥",
                    "desc": "## 本任务要做什么\n- 搞清楚「裸机 / RTOS / Linux」这三个词大概是什么意思。\n- 能说出：自己现在手上的板子 / 项目属于哪一类环境。\n- 先有一张很粗的地图，后面再慢慢学 LibXR 的系统层细节。\n\n## 三种常见运行环境\n### 裸机（Bare-metal）\n- 没有操作系统，只有 `main()` 和一些中断函数。\n- 程序一般是 `while(1)` 死循环，所有调度逻辑都要自己写。\n\n### RTOS（实时操作系统，比如 FreeRTOS / ThreadX）\n- 跑在 MCU 上的一个小型操作系统。\n- 提供「任务/线程」「延时/定时」「队列/信号量」等基础能力。\n- 好处：可以把不同功能拆成多个任务，而不是全塞在一个大循环里。\n\n### Linux / 通用操作系统\n- 常见在树莓派、工控机、x86 开发板等。\n- 有进程/线程、文件系统、网络等完整功能。\n- 我们的程序通常是用户态进程，通过系统调用来使用内核能力。\n\n## 和 LibXR 的关系（先知道有这么一层就行）\n- 这三种环境的底层 API 差别很大：\n  - 裸机几乎没有线程，只剩下循环 + 中断。\n  - RTOS 用 `xTaskCreate` / `tx_thread_create` 之类开任务。\n  - Linux 用 `pthread_create` / `std::thread` 之类。\n- LibXR 会在后面的「系统层」里，用统一的接口（`Thread` / `Mutex` / `Semaphore` / `Async` / `Timer` 等）把这些差异藏起来。\n- 现在你只需要知道：以后会有这么一层帮你做「跨平台统一」，本任务不用看这些细节。\n\n## 你现在实际要做的事\n- 看一下自己当前在用什么，例如：\n  - 「STM32 最小系统，自己写 `while(1)`」 → 裸机。\n  - 「STM32 + FreeRTOS」 → RTOS。\n  - 「树莓派 / Linux 工控机」 → Linux。\n- 在脑子或笔记里写一句总结，比如：\n  - 「当前项目：STM32 + FreeRTOS → RTOS 环境」。\n- 到这里就算完成本任务。\n- 本任务不要求写任何代码，也不要求把文档全部看完，只要能分清自己属于哪一类环境就够了。",
                    "link": "",
                    "estimateMinutes": 10
                },
                {
                    "id": "os_thread_basic",
                    "title": "线程入门：在 RTOS / Linux 跑出第一个 LibXR::Thread",
                    "desc": "## 本任务要做什么\n1. 写出并跑起来第一个 `LibXR::Thread` 示例，让一个工作线程周期性地闪烁 LED 并/或打印日志。\n2. 感受「主线程 + 工作线程」同时运行，为后面的 Mutex 练习做准备。\n3. 初步认识你自己的 OS 环境里的线程概念（主线程 / 工作线程、栈大小、优先级）。\n\n## 适用环境\n1. 工程运行在已集成 LibXR 的环境（例如带 RTOS 的 MCU 或 Linux / 类 Unix 系统）。\n2. 环境应当至少满足：\n   - 可以控制一个可见的指示器（例如板载 LED）。\n   - 可以输出文本（例如串口打印 / 终端 `LibXR::STDIO::Printf`）。\n3. 裸机（没有 RTOS 的 MCU）暂时不适用：后面会有专门的调度方式。\n\n## 预备条件\n1. 工程已经能正常编译、下载并运行。\n2. 工程中已经集成 LibXR 系统层：\n   - 能包含到 `thread.hpp`（或等价路径）并成功编译。\n   - 能看到 `LibXR::Thread` 类，以及 `Create` / `Sleep` / `SleepUntil` / `Yield` 等接口。\n\n## 示例代码\n```cpp\n#include <thread.hpp>\n\nvoid Worker(int* counter)\n{\n    auto last = LibXR::Timebase::GetMilliseconds();\n    while (true)\n    {\n        (*counter)++;                      // 修改计数器，后面 Mutex 会用到\n        // 这里做一件容易观察的事情：例如打印日志并切换 LED 状态\n        // 例如：LibXR::STDIO::Printf(\"worker: %d\", *counter); ToggleLED();\n        LibXR::Thread::SleepUntil(last, 500);  // 每 500 ms 执行一次\n    }\n}\n\nstatic int counter = 0;\nLibXR::Thread worker;\n\nint main()\n{\n    worker.Create(&counter,        // 传给线程函数的参数（类型为 int*）\n                  Worker,          // 线程函数，签名必须是 void(int*)\n                  \"worker\",        // 线程名称，便于调试\n                  2048,            // 线程栈大小（字节），先用 2048 这种安全值\n                  LibXR::Thread::Priority::MEDIUM);  // 普通优先级\n\n    while (true)\n    {\n        // 主线程自己的工作，例如每 1000 ms 打印一次日志并闪烁另一颗 LED\n        // 例如：LibXR::STDIO::Printf(\"main loop\"); ToggleOtherLED();\n        LibXR::Thread::Sleep(1000);   // 1000 ms = 1 s\n    }\n}\n```\n\n## 逐行解释\n### 核心思路\n1. Worker 线程：每 500 ms 醒一次，更新计数器并进行一次可见动作（打印日志 / 闪灯）。\n2. 主线程：每 1000 ms 执行一次自己的逻辑，用来对比两个不同的节奏。\n\n### 关键语句说明\n1. `auto last = LibXR::Timebase::GetMilliseconds();`\n   - 从 LibXR 的时间基准模块中读取当前系统的毫秒计数，后面配合 `SleepUntil` 做固定周期循环。时间单位是毫秒。\n2. `LibXR::Thread::SleepUntil(last, 500);`\n   - 以毫秒为单位的周期睡眠：每次都会睡到 `last + 500`，并在函数内部更新 `last`，形成稳定的 500 ms 周期循环。\n3. `worker.Create(&counter, Worker, \"worker\", 2048, LibXR::Thread::Priority::MEDIUM);`\n   - 创建并启动一个新线程：传入参数指针 `&counter`、线程函数 `Worker`、线程名 `\"worker\"`、栈大小 `2048` 字节、普通优先级。\n4. `LibXR::Thread::Sleep(1000);`\n   - 让当前线程休眠 `1000 ms`（1 秒），形成与工作线程不同的节奏。\n\n## 编译与运行\n### 编译\n- 确认工程已经链接了对应平台的 `thread.cpp` 实现，然后按平时的方法编译（`make` / `ninja` / IDE 按钮均可）。\n\n### 运行与观察\n1. 烧录 / 运行程序后，你应该能看到：\n   - 一个线程以大约 500 ms 的节奏更新计数器，并做一次可见动作（打印 / 闪灯）。\n   - 主线程以大约 1000 ms 的节奏做自己的可见动作。\n2. 如果只看到一个节奏在动：\n   - 检查 `worker.Create` 是否真的被执行。\n   - 可以尝试把栈大小调大一点（例如 `4096`），或者把线程优先级调高。\n\n## 名词小抄\n- **线程（Thread）**：操作系统调度的基本执行单元，可以把不同功能拆成多个线程并发运行。\n- **主线程**：`main()` 所在的线程，程序一开始就在这里跑。\n- **工作线程**：由 `LibXR::Thread::Create` 创建出来，专门负责某一类工作（如闪灯、采样、通信）。\n- **栈大小（stack）**：给线程分配的函数调用栈空间，单位通常是字节，需要留出足够余量防止栈溢出。\n\n## 为后续任务做准备\n- 保留好这份工程，后面的 Mutex 练习会在这个示例上直接加入互斥锁来保护 `counter`。\n\n## 相关文档\n- [Thread（线程）文档](https://xrobot-org.github.io/docs/basic_coding/system/thread)",
                    "link": "https://xrobot-org.github.io/docs/basic_coding/system/thread",
                    "estimateMinutes": 20
                },
                {
                    "id": "os_mutex_basic",
                    "title": "互斥锁入门：用 LibXR::Mutex 保护共享计数器",
                    "desc": "## 本任务要做什么\n1. 在上一任务的基础上，引入 `LibXR::Mutex`，让主线程和工作线程安全地共享同一个计数器。\n2. 体验「不加锁 vs 加锁」的差异，理解什么是临界区。\n3. 熟悉 `LibXR::Mutex` 和 `LibXR::Mutex::LockGuard` 的基本用法。\n\n## 预备条件\n1. 已完成「线程入门」任务，工程中有一个主线程 + 一个工作线程，并共享整型变量（例如 `counter`）。\n2. 已能正常编译、下载并运行该工程。\n\n## 实现步骤\n1. **声明互斥锁和共享变量**（全局或合适的作用域）：\n```cpp\n#include <mutex.hpp>\n\nLibXR::Mutex g_counter_mutex;\nint g_counter = 0;\n```\n\n2. **在工作线程中加锁访问 `g_counter`**：\n```cpp\nvoid Worker()\n{\n    while (true)\n    {\n        {\n            LibXR::Mutex::LockGuard lock(g_counter_mutex); // 构造时加锁\n            g_counter++;                                   // 临界区：修改共享数据\n            // 这里可以打印一下当前计数值\n            // 例如：LibXR::STDIO::Printf(\"worker: %d\\n\", g_counter);\n        } // 作用域结束，LockGuard 析构自动解锁\n\n        LibXR::Thread::Sleep(500); // 保持原来的节奏\n    }\n}\n```\n\n3. **在主线程中同样使用互斥锁访问 `g_counter`**：\n```cpp\nint main()\n{\n    // 创建工作线程（可复用上一任务的代码）\n    // ... worker.Create(...);\n\n    while (true)\n    {\n        {\n            LibXR::Mutex::LockGuard lock(g_counter_mutex);\n            // 在主线程中读取 / 打印 g_counter\n            // 例如：LibXR::STDIO::Printf(\"main: %d\\n\", g_counter);\n        }\n\n        LibXR::Thread::Sleep(1000);\n    }\n}\n```\n\n4. **（可选）尝试去掉互斥锁对比效果**：\n   - 暂时注释掉 `LockGuard`，只保留对 `g_counter` 的读写。\n   - 视平台和优化情况，你可能会观察到：打印顺序异常、重复、跳号等现象，或者表面上看不出问题，但这并不代表没有竞争条件，只是没被触发出来。\n\n## 名词小抄\n- **临界区（Critical Section）**：多线程可能同时访问/修改的共享数据区域，例如同一个全局计数器、同一块缓冲区。\n- **互斥锁（Mutex）**：用来保证某一时刻只有一个线程可以进入临界区的锁，避免数据竞争。\n- **RAII**：一种 C++ 习惯用法，利用对象构造/析构自动管理资源（这里指“自动加锁/解锁”）。\n\n## 注意事项\n- 互斥锁只能在「线程上下文」使用，不能在中断服务程序（ISR）里加锁 / 解锁；如果需要在 ISR 中保护数据，后续会用专门的临界区 / 原子操作方式。\n- 尽量使用 `LockGuard` 这种 RAII 封装，避免「加锁后早退却没解锁」之类的错误。\n\n## 完成标准\n### 功能完成\n1. 工程能够正常编译、下载并运行。\n2. 主线程和工作线程都在访问同一个 `g_counter`，且访问时都通过 `LibXR::Mutex::LockGuard` 保护。\n3. 打印 / LED 行为看起来正常，程序不出现明显异常（卡死、频繁报错）。\n\n### 理解到位\n1. 能用自己的话解释：什么是临界区，为什么对 `g_counter++` 这种操作也需要互斥保护。\n2. 能说出：`Mutex` 的三个核心操作（`Lock` / `TryLock` / `Unlock`）分别在什么场景下使用。\n3. 能说明：为什么推荐用 `LockGuard` 来管理锁的生命周期，而不是手动成对调用 `Lock` / `Unlock`。\n\n## 相关文档\n- [Mutex（互斥锁）文档](https://xrobot-org.github.io/docs/basic_coding/system/mutex)\n- [Thread（线程）文档](https://xrobot-org.github.io/docs/basic_coding/system/thread)",
                    "link": "https://xrobot-org.github.io/docs/basic_coding/system/mutex",
                    "estimateMinutes": 30
                },
                {
                    "id": "os_semaphore_basic",
                    "title": "信号量 + 回调入门：用 LibXR::Semaphore 和 Callback 通知线程",
                    "desc": "## 本任务要做什么\n1. 在前面“线程 + 互斥锁”基础上，引入 `LibXR::Semaphore`，用信号量来做“事件通知”。\n2. 按照 `LibXR::Thread` 的正式接口写出正确的线程函数和 `Create()` 参数。\n3. 按照 `LibXR::Callback` 的正式接口写出一个带 `bool in_isr` 的回调，用它在 ISR / 线程中安全地 `PostFromCallback()` 信号量。\n4. 理解信号量和互斥锁在用途上的区别：一个偏“事件/计数”，一个偏“互斥访问”。\n\n## 预备知识回顾\n### 1. Thread::Create 的正确形态\n- 接口：\n  - `template <typename Arg> void Create(Arg arg, void (*func)(Arg), const char* name, size_t stack, Priority prio);`\n- 关键点：\n  1. 线程函数的参数类型 **必须和 `arg` 的类型完全一致**，如：\n     - `void Worker(LibXR::Semaphore* sem);`\n     - `t.Create(&g_sem, Worker, \"sem_worker\", 2048, Priority::MEDIUM);`\n  2. `stack` 和 `prio` 的单位/解释由各个平台自己的适配层处理，上层只负责给“一个合理的栈大小”和“一个大概的优先级”。\n\n### 2. Callback 的正确形态\n- 核心声明：\n  - 回调函数原型：`void(bool in_isr, BoundArgType ctx, Args... args)`。\n  - 创建：`auto cb = LibXR::Callback<Args...>::Create(fun, bound_arg);`\n  - 调用：`cb.Run(in_isr, arg1, arg2, ...);`\n- 本任务里我们只绑定一个 `LibXR::Semaphore*`，不需要额外参数：\n  - 回调函数：`void OnButtonEvent(bool in_isr, LibXR::Semaphore* sem)`。\n  - 类型：`LibXR::Callback<>`（没有额外 Args）。\n  - 创建：`LibXR::Callback<> g_button_cb = LibXR::Callback<>::Create(OnButtonEvent, &g_sem);`\n  - 调用：`g_button_cb.Run(true);`（在 ISR）、`g_button_cb.Run(false);`（在普通线程）。\n\n## 名词小抄\n- **信号量（Semaphore）**：线程之间用来“计数 + 通知”的同步原语，常用来表示“有多少个事件/资源可用”。\n- **回调（Callback）**：把函数和一部分参数先“封装/绑定”起来，等事件发生时再统一调用。\n- **ISR（中断服务程序）**：被硬件中断触发的函数，执行时间应尽量短，不能做会长时间阻塞的操作（例如 `Wait()`）。\n\n## 示例代码：线程 + 信号量 + 回调\n```cpp\n#include <thread.hpp>\n#include <semaphore.hpp>\n#include <callback.hpp>   // 实际工程按你的路径调整\n\n// 1. 全局信号量：初始计数为 0，表示一开始没有事件\nLibXR::Semaphore g_sem(0);\n\n// 2. 回调函数：签名必须符合 void(bool, BoundArgType, Args...)\nvoid OnButtonEvent(bool in_isr, LibXR::Semaphore* sem)\n{\n    // 在 ISR 或普通上下文中安全释放信号量\n    sem->PostFromCallback(in_isr);\n}\n\n// 3. 回调对象：绑定第一个参数为 &g_sem\nLibXR::Callback<> g_button_cb = LibXR::Callback<>::Create(OnButtonEvent, &g_sem);\n\n// 4. 线程函数：参数类型 = Create 传入的 Arg 类型（这里是 LibXR::Semaphore*）\nvoid Worker(LibXR::Semaphore* sem)\n{\n    while (true)\n    {\n        // 等待一次事件，最多等 1000 ms\n        auto ec = sem->Wait(1000);\n        if (ec == ErrorCode::OK)\n        {\n            // 收到一次“事件”，做一件明显的事情\n            // 例如：LibXR::STDIO::Printf(\"sem: got event\\n\");\n            //       ToggleLED();\n        }\n        else if (ec == ErrorCode::TIMEOUT)\n        {\n            // 超时没等到事件，也可以顺便做点别的（可选）\n            // 例如：LibXR::STDIO::Printf(\"sem: timeout\\n\");\n        }\n    }\n}\n\nint main()\n{\n    LibXR::Thread t;\n\n    // 5. 按照接口正确调用 Create：\n    //    Arg           = LibXR::Semaphore*\n    //    func          = void(LibXR::Semaphore*)\n    //    name/stack/prio 按平台习惯给值\n    t.Create(&g_sem,                           // arg：传给线程函数的参数\n             Worker,                           // func：线程入口函数\n             \"sem_worker\",                    // name：线程名（调试用）\n             2048,                             // stack：栈大小（字节）\n             LibXR::Thread::Priority::MEDIUM); // prio：优先级\n\n    while (true)\n    {\n        // 用主线程来“模拟”每 2 s 触发一次外部事件\n        LibXR::Thread::Sleep(2000);\n\n        // 在线程上下文中触发回调：in_isr = false\n        g_button_cb.Run(false);\n\n        // 在真实项目里，你会在按键/定时器/ DMA ISR 中写：\n        // g_button_cb.Run(true);\n    }\n}\n```\n\n## 注意事项\n1. `Worker` 的函数签名必须是 `void(LibXR::Semaphore* sem)`，因为你在 `Create` 里传的是 `&g_sem`（类型为 `LibXR::Semaphore*`）。\n2. 回调函数 `OnButtonEvent` 的签名必须是 `void(bool in_isr, LibXR::Semaphore* sem)`，第一个参数永远是 `bool in_isr`，第二个是你通过 `Callback::Create` 绑定的 `BoundArgType`（这里是 `LibXR::Semaphore*`）。\n3. `Wait()` 只能在线程上下文调用，不能在 ISR 里调用；在 ISR 中只调用 `PostFromCallback(true)`，交给信号量去唤醒等待线程。\n4. 如果你的平台暂时没有真实中断，可以像示例那样在主线程里用 `Sleep + g_button_cb.Run(false)` 模拟事件，以后直接把 `Run(true)` 挪到真实 ISR 里即可。\n\n## 完成标准\n### 功能完成\n1. 工程能正常编译、下载并运行，没有因函数签名不匹配导致的链接/运行错误。\n2. 线程通过 `LibXR::Semaphore::Wait()` 等待事件，回调通过 `PostFromCallback()` 触发事件，行为可通过打印或 LED 清晰观测到。\n3. 调整事件触发频率（例如把 `Sleep(2000)` 改成 `Sleep(500)`），能够明显看到线程响应节奏的变化。\n\n### 理解到位\n1. 你能说清楚：`Thread::Create` 的每个参数分别是什么意思，线程函数的参数类型为什么必须和 `arg` 一致。\n2. 你能写出一个最小的 Callback 示例：`void(bool, ContextType, ...)` + `Callback<...>::Create(...)` + `Run(in_isr, ...)`。\n3. 你能用自己的话解释：为什么在 ISR 里只能 `PostFromCallback(true)`，不能 `Wait()`；以及信号量和互斥锁的用途差异。\n\n## 相关文档\n- [Semaphore（信号量）文档](https://xrobot-org.github.io/docs/basic_coding/system/semaphore)\n- [Callback（通用回调）文档](https://xrobot-org.github.io/docs/basic_coding/system/callback)\n- [Thread（线程）文档](https://xrobot-org.github.io/docs/basic_coding/system/thread)",
                    "link": "https://xrobot-org.github.io/docs/basic_coding/system/semaphore",
                    "estimateMinutes": 30
                },
                {
                    "id": "os_timer_basic",
                    "title": "定时器入门：用 LibXR::Timer 跑出周期任务",
                    "desc": "## 本任务要做什么\n1. 在前面「线程 + 互斥锁 + 信号量」基础上，引入 `LibXR::Timer`，用“定时任务”来替代手写 `while (true) + Sleep` 循环。\n2. 写出并跑起来一个最简单的定时任务：每 1000 ms 打印一行日志 / 闪烁 LED。\n3. 学会在运行时修改任务周期（`SetCycle`），以及启动 / 停止定时任务（`Start` / `Stop`）。\n4. 理解：`LibXR::Timer` 适用于 **对实时性要求不高** 的周期性任务，所有任务共享同一个调度机制，不需要为每个任务单独开线程栈，比较节省资源。\n\n## 适用场景\n- 适合做：\n  - 周期打印状态、喂狗、上报心跳、轮询某个状态等“软实时”任务；\n  - 对抖动不敏感，只要“差不多按周期执行”就可以的逻辑。\n- 不适合做：\n  - 对时序特别严格的控制环（硬实时控制），比如电机 FOC 里的高速环；这种更适合：\n    - 专门的高优先级线程 + `Thread::SleepUntil`；\n    - 或硬件定时器 + RTOS 原生 timer / 中断。\n\n## 适用环境\n1. 工程运行在已集成 LibXR 的环境（例如带 RTOS 的 MCU 或 Linux / 类 Unix 系统），并且：\n   - 已完成 Timebase 配置，可以正常调用 `LibXR::Timebase::GetMilliseconds()`。\n   - 建议已经做过 `Thread` / `Mutex` / `Semaphore` 练习（不强制，但会更好理解）。\n2. 裸机环境同样可以使用 `LibXR::Timer`，只要 Timebase 正常工作即可。\n\n## 名词小抄\n- **Timebase（时间基准）**：提供系统启动以来的毫秒计数，例如 `LibXR::Timebase::GetMilliseconds()`；所有定时逻辑都以它为参考。\n- **Timer（定时器）**：LibXR 内部的“软件定时器调度器”，你只需要注册回调和周期，不用自己管遍历和计时。\n- **TimerHandle（定时任务句柄）**：`LibXR::Timer::CreateTask` 返回的句柄，用来后续 `Start` / `Stop` / `SetCycle` / `Add`。\n- **Timer 管理线程**（RTOS / 多线程环境）：LibXR 内部起的一个线程，周期性调用 `Timer::Refresh()`，统一调度所有定时任务。\n- **裸机空闲刷新**：在没有真正线程的裸机环境，LibXR 会在 `Thread` 延时、Mutex、信号量等待时调用 `RefreshTimerInIdle()`，顺带把定时任务刷一遍。\n\n## 示例一：最简单的周期打印任务\n目标：每 1000 ms 执行一次任务（打印日志 / 闪烁 LED），主线程不用自己写 `while(true) + Sleep` 调度逻辑。\n\n```cpp\n#include <thread.hpp>\n#include <timer.hpp>\n\n// 要周期执行的任务函数：参数类型要和 CreateTask 的 arg 类型一致（这里是 int*）\nvoid PrintHello(int* value)\n{\n    // 这里可以替换成串口打印 / 板载 LED 闪烁等\n    // 例如：LibXR::STDIO::Printf(\"Hello, value = %d\\n\", *value);\n    ToggleLED();\n}\n\nint main()\n{\n    static int arg = 123;  // 参数要在整个任务生命周期内有效（static / 全局更安全）\n\n    // 1. 创建定时任务：每 1000 ms 调用一次 PrintHello\n    auto handle = LibXR::Timer::CreateTask(PrintHello, &arg, 1000);\n\n    // 2. 把任务加入 LibXR 的定时调度列表（同一个 handle 只需要 Add 一次）\n    LibXR::Timer::Add(handle);\n\n    // 3. 启动任务\n    LibXR::Timer::Start(handle);\n\n    // 4. 主线程可以什么都不做，或者做别的事\n    while (true)\n    {\n        // RTOS / 多线程：Timer 内部有单独管理线程负责调度本任务，不需要你手动 Refresh\n        // 裸机：在 LibXR 的 Thread 延时 / Mutex / 信号量等待中会自动调用 RefreshTimerInIdle\n        LibXR::Thread::Sleep(UINT32_MAX);  // 这里简单地“睡很久”\n    }\n}\n```\n\n### 代码要点说明\n1. `void PrintHello(int* value)`  \n   - 函数参数类型是 `int*`，所以在 `CreateTask` 时传入的 `arg` 必须也是 `int*`（这里是 `&arg`）。\n2. `LibXR::Timer::CreateTask(PrintHello, &arg, 1000);`  \n   - 创建一个周期为 1000 ms 的定时任务，返回 `TimerHandle`。\n   - 内部为这个任务分配控制块，但 **不会** 为它单独开一个线程栈；多个定时任务共用同一个调度机制（一个管理线程，或裸机空闲刷新）。\n3. `LibXR::Timer::Add(handle);`  \n   - 把任务加入内部任务列表：\n     - **RTOS / 多线程环境**：第一次 `Add` 时会创建定时器管理线程（`RefreshThreadFunction`），这个线程用 `Thread::SleepUntil` 以 1ms 精度轮询并调度所有任务。\n     - **裸机环境**：不会创建线程，只是初始化列表，之后靠 `RefreshTimerInIdle()` 刷新。\n4. `LibXR::Timer::Start(handle);`  \n   - 启用这个定时任务；之后，由 Timer 管理逻辑按周期调用任务函数。\n5. `LibXR::Thread::Sleep(UINT32_MAX);`  \n   - 示例里主线程什么都不干，只是防止退出。真实工程中，你可以在这里放自己的业务循环。\n\n## 示例二：运行中修改周期（SetCycle）\n在上面的基础上，再加几行代码：\n\n```cpp\n// 在 main 里创建好任务、Add/Start 之后：\nLibXR::Thread::Sleep(5000);           // 先等 5 秒\nLibXR::Timer::SetCycle(handle, 200);  // 把周期改成 200 ms\n```\n\n观察现象：\n- 前 5 秒任务大约每 1 秒执行一次；\n- 之后任务执行频率明显变快，大约 0.2 秒一次。\n\n## 示例三：暂停与恢复定时任务\n```cpp\n// 同样在 main 中：\nLibXR::Thread::Sleep(10000);  // 运行 10 秒\nLibXR::Timer::Stop(handle);   // 暂停任务 3 秒\nLibXR::Thread::Sleep(3000);\nLibXR::Timer::Start(handle);  // 再次启动\n```\n\n## 注意事项\n1. **参数生命周期要足够长**  \n   - `CreateTask` 内部保存的是指向 `arg` 的指针，不会拷贝整个对象；\n   - 所以 `arg` 必须在整个定时任务的生命周期内保持有效（建议使用 `static` / 全局变量，或者比定时任务活得更久的对象）。\n\n2. **Add 只能调用一次**  \n   - 每个 `TimerHandle` 只能 `Add` 一次；重复添加会触发断言 `ASSERT(!handle->next_)`。\n\n3. **周期单位是毫秒，且不是硬实时**  \n   - 所有 `cycle` / `SetCycle` 参数单位都是毫秒：`1` 表示 1 ms，`1000` 表示 1 s；\n   - LibXR 内部通过 `Thread::SleepUntil` + 软件计数实现调度，精度可以达到 ms 级，但仍然受线程调度和中断影响，**不是绝对硬实时**。\n\n4. **RTOS / 多线程环境的实现**  \n   - Timer 会通过 `RefreshThreadFunction` 启动一个真正的管理线程（`LibXR::Timer::thread_handle_`），在这个线程里：\n     - 用 `Thread::GetTime()` / `Thread::SleepUntil` 做 1 ms tick；\n     - 周期性调用 `Timer::Refresh()` 遍历任务列表并触发任务。\n   - 每个定时任务本身不会再起独立线程，大家共享这一个管理线程的栈和调度逻辑，因此对 RAM 更友好。\n\n5. **裸机场景的实现**  \n   - 裸机下没有真正的 OS 线程，LibXR 不会创建管理线程；\n   - 而是通过 `RefreshTimerInIdle()` 在以下情况被自动调用：\n     - `Thread` 延时；\n     - Mutex / 信号量等待等“空闲”时机；\n   - 这样利用“原本就要空转的时间”顺带刷新定时器，同样达成周期任务效果。\n\n## 完成标准\n### 功能完成\n1. 至少创建一个定时任务，通过 `LibXR::Timer::CreateTask` + `Add` + `Start` 正常运行。\n2. 能从日志或 LED 行为中明显观察到“每隔一段时间执行一次”的现象（软实时即可，无需精确到每个 tick）。\n3. 能在运行时通过 `SetCycle` 明显改变任务执行频率（例如从 1000 ms 改成 200 ms）。\n4. 能通过 `Stop` / `Start` 暂停并恢复任务执行。\n\n### 理解到位\n1. 能解释：\n   - Timer 和“给每个任务单独开线程 + while(true) + SleepUntil”相比的优点（更节省栈、更统一的调度）；\n   - Timer 是一个“软实时软件定时器”，不适合做硬实时控制环。\n2. 能说清楚：\n   - `CreateTask` 返回的 `TimerHandle` 用来做什么；\n   - 为什么回调参数类型必须和 `CreateTask` 的 `arg` 类型一致；\n   - 为什么 `arg` 不能是一个随手写在函数里的局部变量。\n3. 能区分：\n   - **RTOS / 多线程环境**：Timer 由一个真正的管理线程驱动；\n   - **裸机环境**：Timer 依赖空闲时的 `RefreshTimerInIdle()` 刷新。\n\n## 相关文档\n- [Timer（定时器）文档](https://xrobot-org.github.io/docs/basic_coding/system/timer)\n- [Timebase（时间基准）配置示例 · STM32](https://xrobot-org.github.io/docs/code_gen/stm32/stm32-code-gen-timebase)\n- [Thread（线程）文档](https://xrobot-org.github.io/docs/basic_coding/system/thread)",
                    "link": "https://xrobot-org.github.io/docs/basic_coding/system/timer",
                    "estimateMinutes": 20
                },
                {
                    "id": "os_async_basic",
                    "title": "异步任务入门：用 LibXR::ASync 把耗时操作丢到后台跑",
                    "desc": "## 本任务要做什么\n1. 认识 `LibXR::ASync`：它内部有 **专用工作线程 + 计数信号量**，帮你把「比较耗时」的操作丢到后台线程执行。\n2. 写出并跑起来第一个异步任务：在主循环 / ISR 里提交 Job，后台线程做“重活”，主线程只轮询状态。\n3. 学会区分：什么时候该用 `ASync`，什么时候直接写线程 / Timer / 普通回调就够了。\n\n---\n\n## 适用场景\n- 适合：\n  - 传感器中断里，只想“快点退 ISR”，把后续的 FFT / CRC / 过滤放到后台线程算。\n  - 主循环里，有一个会占用几十毫秒的检查/校验，把它拆出去不阻塞主循环。\n  - 想用“一个工作线程 + 排队任务”的方式跑一些计算，但又懒得自己写线程 + 队列 + 信号量。\n- 不适合：\n  - 完全不允许抖动、对时序极端敏感的硬实时控制（例如高速电机控制环）；\n  - 会一直阻塞、死循环的任务（会把这个 ASync 实例完全堵死）。\n\n每个 `ASync` 实例内部只有 **一个工作线程**：同一时间只执行一个 Job，新的 Job 在前一个没跑完时提交会返回 `ErrorCode::BUSY`。\n\n---\n\n## 名词小抄\n- **ASync 实例**：`LibXR::ASync` 的一个对象，内部自带一个工作线程 + 一个计数信号量。\n- **Job**：`using Job = LibXR::Callback<ASync*>;`，本质是一个带 `ASync*` 参数的回调。\n  - 回调函数签名：`void(bool in_isr, BoundArgType ctx, LibXR::ASync* self)`。\n  - 通过 `LibXR::ASync::Job::Create(fun, bound_arg)` 创建。\n- **Status**：`GetStatus()` 返回：\n  - `READY`：当前没有 Job 在执行；\n  - `BUSY`：工作线程正在执行一个 Job；\n  - `DONE`：上一个 Job 已经执行完成，本次读取会看到 `DONE`，并自动复位为 `READY`。\n- **设计说明**：\n  - 在 LibXR 的设计理念里，“普通 Callback”默认是 **短平快、不阻塞** 的；\n  - 这里虽然复用了 `Callback` 的实现，但给它起了一个新名字 **Job**，明确告诉你：\n    - Job 是跑在 **专用线程** 里的，可以做稍微重一点的工作（如 FFT / 解压 / 校验）；\n    - 但依然不建议在里面写无限阻塞或超长耗时逻辑，否则整个 ASync 会被这个 Job 拖住。\n\n---\n\n## 前置条件\n1. 工程已经能正常使用：\n   - `LibXR::Thread`（线程）\n   - `LibXR::Semaphore`（信号量）\n2. 环境允许创建至少一个工作线程：\n   - RTOS / Linux / 其它多线程环境：ASync 会真实创建一个工作线程；\n   - 裸机：可以配置为“同步执行”，即提交 Job 时直接跑，ASync 退化成一个“函数调用壳”。\n\n---\n\n## Job 函数签名与创建方式\n### 1. 回调函数签名\n按照 `Callback` 的定义，Job 的本质是：\n\n- 类型别名：`using Job = LibXR::Callback<ASync*>;`\n- 函数原型：`void(bool in_isr, BoundArgType ctx, LibXR::ASync* self);`\n\n例如，我们要做一个“模拟耗时计算”的 Job：\n\n```cpp\nvoid HeavyCalc(bool in_isr, int* ctx, LibXR::ASync* self)\n{\n    (void)in_isr; // 这里不需要用到可先忽略\n\n    // 模拟一个 5~10ms 的耗时操作（真实工程中换成 DoFFT / 校验等）\n    // 注意：这里 Sleep 只是演示，现实中通常是计算本身耗时\n    LibXR::Thread::Sleep(5);\n\n    // 例如根据 *ctx 写入某个结果缓冲区\n    // DoFFT(*ctx);\n}\n```\n\n### 2. 创建 Job 对象\n```cpp\nstatic int g_arg = 0;  // 被 Job 使用的上下文参数，生命周期要足够长\n\nLibXR::ASync::Job g_async_job = LibXR::ASync::Job::Create(HeavyCalc, &g_arg);\n// 这里：\n// - BoundArgType = int*\n// - Job 类型 = Callback<LibXR::ASync*>，所以 Args... = LibXR::ASync*\n// HeavyCalc 实际签名为：void(bool, int*, LibXR::ASync*)\n```\n\n---\n\n## 示例：中断提交 Job，主循环轮询状态\n目标：\n- 模拟“传感器采样完成中断”里提交一个耗时计算 Job；\n- 主循环里定期查 `GetStatus()`，在 Job 完成后取结果并做后续处理。\n\n```cpp\n#include <thread.hpp>\n#include <semaphore.hpp>\n#include <async.hpp>\n#include <callback.hpp>\n\n// 1. 创建一个异步工作器：内部会起一个专用线程\nLibXR::ASync g_async_worker(2048, LibXR::Thread::Priority::NORMAL);\n\n// 2. Job 对应的上下文数据（示例中用一个 int 占位，真实工程可换成缓冲区等）\nstatic int g_arg = 0;\n\n// 3. Job 回调函数：签名必须是 void(bool, BoundArgType, LibXR::ASync*)\nvoid HeavyCalc(bool in_isr, int* ctx, LibXR::ASync* self)\n{\n    (void)self;\n\n    // 中断环境标志：如果你需要区分“是从 ISR 提交的任务”可以用 in_isr 做分支\n    // 这里仅示意，不特别区分\n\n    // 模拟耗时计算\n    LibXR::Thread::Sleep(5);\n\n    // 根据 *ctx 计算并写入某个全局结果（此处略）\n    // DoFFT(*ctx);\n}\n\n// 4. 全局 Job 对象：可以在任务和 ISR 中反复提交\nLibXR::ASync::Job g_async_job = LibXR::ASync::Job::Create(HeavyCalc, &g_arg);\n\n// 5. 模拟传感器中断服务程序：在 ISR 中提交 Job\nvoid SensorISR()\n{\n    // 在中断/回调上下文提交任务，isr = true\n    g_async_worker.AssignJobFromCallback(g_async_job, true);\n}\n\nint main()\n{\n    while (true)\n    {\n        // 在实际工程中，SensorISR 会被硬件中断触发\n        // 这里我们简单地每 100ms 调用一次 ISR 进行模拟\n        LibXR::Thread::Sleep(100);\n        SensorISR();\n\n        // 主循环中轮询 ASync 的状态\n        auto st = g_async_worker.GetStatus();\n        if (st == LibXR::ASync::Status::DONE)\n        {\n            // 表示上一次提交的 Job 已经执行完毕\n            // 在这里读取处理结果 / 上报 / 刷 UI 等\n            // 例如：PublishResult();\n        }\n\n        // 如果需要在任务上下文提交，也可以：\n        // if (g_async_worker.AssignJob(g_async_job) == ErrorCode::BUSY) {\n        //     // 当前有任务在跑，可以选择丢弃、排队、或者下次再试\n        // }\n    }\n}\n```\n\n---\n\n## 注意事项\n1. **一个 ASync 实例 = 一个工作线程 = 一次只跑一个 Job**  \n   - 如果在 Job 正在执行时再次调用 `AssignJob()`：\n     - 会返回 `ErrorCode::BUSY`，说明当前 worker 忙；\n     - 你需要自己决定：丢弃、稍后重试、还是忽略这次事件。\n\n2. **Job 中可以稍微耗时，但不要“作死”**  \n   - Job 跑在专用线程里，可以做 FFT、压缩、校验等会消耗几毫秒到几十毫秒的工作；\n   - 但不建议：\n     - 在 Job 里无限循环；\n     - 长时间阻塞等待别的任务（尤其是再去等同一个 ASync 的状态），容易形成死锁或把 worker 完全堵死。\n\n3. **回调/Job 的“阻塞规则”差异**  \n   - 普通 `Callback` 在 LibXR 设计理念里是“**不可阻塞、不可长时间延时**”的轻量回调；\n   - `ASync::Job` 虽然底层用的是同一套 Callback 模板，但语义不同：\n     - 它就是拿来跑“相对重一点的活”的，因此命名为 Job；\n     - 仍需自我节制，尽量避免无意义的 `Sleep` 或过长的 IO 阻塞。\n\n4. **`GetStatus()` 的语义**  \n   - `READY`：可以提交新 Job；\n   - `BUSY`：当前 Job 在执行中；\n   - `DONE`：上一 Job 刚执行完，本次读到后会自动复位为 `READY`（适合在主循环里简单 if 判断）。\n\n5. **裸机场景**  \n   - 如果系统不支持线程，ASync 可以在实现里退化为“同步执行”：`AssignJob()` 直接 `job.Run()`；\n   - 在这种模式下，`ASync` 仍然提供统一接口，只是失去了“真正后台执行”的能力。\n\n---\n\n## 完成标准\n### 功能完成\n1. 至少创建一个 `LibXR::ASync` 实例，并正确构造一个 `Job`：`LibXR::ASync::Job::Create(HeavyCalc, &ctx)`。\n2. 能从任务上下文或模拟 ISR 中成功提交 Job：\n   - `AssignJob()` 在 READY 状态下返回 `ErrorCode::OK`；\n   - `AssignJobFromCallback()` 能在“伪 ISR”中被调用而不导致异常。\n3. 主循环中能通过 `GetStatus()` 观察到从 `BUSY` -> `DONE` -> `READY` 的状态变化。\n\n### 理解到位\n1. 能说清楚：\n   - ASync 和 Timer / Thread / 普通 Callback 各自适合做什么；\n   - 为什么 ASync 的 Job 被设计成 `Callback<ASync*>`；\n   - 为什么这里刻意把“Callback”这个名字换成“Job”，避免和“不可阻塞的轻量回调”的概念混淆。\n2. 能根据业务需求大致判断：\n   - 某个耗时操作是不是适合丢给 ASync；\n   - 怎样处理 `AssignJob()` 返回 `ErrorCode::BUSY` 的情况（丢弃 / 重试 / 合并）。\n\n## 相关文档\n- [ASync（异步任务）文档](https://xrobot-org.github.io/docs/basic_coding/system/async)\n- [Callback（通用回调）文档](https://xrobot-org.github.io/docs/basic_coding/system/callback)\n- [Semaphore（信号量）文档](https://xrobot-org.github.io/docs/basic_coding/system/semaphore)\n- [Thread（线程）文档](https://xrobot-org.github.io/docs/basic_coding/system/thread)",
                    "link": "https://xrobot-org.github.io/docs/basic_coding/system/async",
                    "estimateMinutes": 30
                }
            ]
        }
    }
}