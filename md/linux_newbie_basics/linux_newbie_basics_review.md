## 本任务目标
- 把这一章在 Linux 上做过的几件小事串起来：
  - 最小的循环 + `Sleep`。
  - 用一个 `bool` 表示“LED 状态”。
  - 把 LibXR 终端和 RamFS 跑起来。
- 明确 Linux 路线现在的定位：
  - 先把“线程 / 时间 / 中间件”这些概念在 PC 上练熟。
  - MCU 真正的 GPIO / 串口等硬件，交给另一条路线去详细展开。

## 你现在已经有的东西
- 一个可重复使用的 Linux 工程骨架 `xr_hello_linux`：
  - 顶层 `CMakeLists.txt` + `User/main.cpp` + `libxr/` 源码目录。
  - 能在 VS Code 中通过底部 **Build** 按钮稳定构建。
  - 能通过底部 **Run** 按钮直接运行可执行文件。
- 在 `main.cpp` 里：
  - 知道在启动时要先调用 `LibXR::PlatformInit();`。
  - 写过一个循环，用 `LibXR::Thread::Sleep` 控制节奏。
  - 用一个 `bool led_on` 当作“LED 状态”，并按需打印日志。
  - 能创建 `LibXR::RamFS` 和 `LibXR::Terminal`，并用 `LibXR::Thread` 把终端跑在单独线程里。

## 以后看到“硬件相关”的示例可以怎么理解
- 虽然现在在 Linux 上没有真实 GPIO，模式是一样的：
  - 用一个变量表示硬件状态（比如“灯亮 / 灭”）。
  - 用一个线程或循环按一定条件去修改它。
  - 通过日志或命令行查看 / 控制这个状态。
- MCU 路线上出现的 LibXR GPIO / UART 类虽然更复杂，但思路是一致的：
  - 只是把 `bool` 换成了驱动类对象，背后帮你做了寄存器和中断相关的工作。

## Terminal + RamFS 在 Linux 路线里的作用
- Terminal：
  - 让你在 PC 上就能体验“命令行中间件”的感觉，和 MCU 使用的是同一套接口和行为。
  - 以后可以尝试把某些小功能挂成命令，比如：用命令控制 `led_on`，或打印调试信息。
- RamFS：
  - 目前主要是给终端提供目录和状态，本章不要求操作具体文件。
  - 真正需要“用文件组织配置和脚本”时，再单独开章节细讲。

## 和后续章节的关系
- 下一章 `os_api_basics` 会更多站在“操作系统 API”的视角用 LibXR：
  - 更系统地看线程、同步原语、定时器等。
  - 在 Linux 上写出结构更清晰的多线程小程序。
- 这一章的目标已经达成：
  - 你知道如何把 LibXR 当普通 C++ 库接到自己的工程里。
  - 你用 VS Code 的 **Build** / **Run** 完成了构建和运行，不再依赖零散命令行。
  - 你见过 LibXR 的终端和 RamFS，大概知道“以后很多功能会挂在这套终端环境上”。

## 完成标准
- 你可以用自己的话描述当前 `xr_hello_linux` 工程有哪些部分，以及各自负责什么。
- 你理解：Linux 路线里的“LED”只是一个帮助你练习思想的布尔量，真正的硬件控制留给 MCU 路线。
- 你清楚：
  - 构建和运行都推荐通过 VS Code 底部的 **Build** / **Run** 按钮完成。
  - 终端和 RamFS 是后续很多能力的承载环境，在 Linux 上先熟悉它们，会让 MCU 路线轻松很多。
