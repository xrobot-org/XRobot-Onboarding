## 本任务目标
- 回顾前面几个任务，从整体上把“工程配置 → 代码生成 → LibXR 初始化 → 自己写逻辑”这条链路串起来。
- 不只是记住“怎么点灯、怎么发串口”，而是形成一套以后可以反复使用的查文档和排错方法。
## 一、你目前已经具备的基础
可以先在脑中快速过一遍自己已经做过的事情：
- 环境层面：
  - 能在 Windows 上用 VS Code + STM32 插件打开、构建和下载 STM32 CMake 工程。
  - 知道 Python / pip 在哪里，安装过 libxr（CodeGenerator）和 xrobot（后面会用到）。
- 工程和 LibXR：
  - 用 STM32CubeMX 生成过基础工程，知道 .ioc 在哪、Core/ 和 Drivers/ 大致放什么。
  - 用 CodeGenerator（例如 xr_cubemx_cfg）在原工程上集成过 LibXR，见过新出现的 Middlewares/Third_Party/LibXR 和 User/app_main.cpp 等文件。
  - 知道 app_main() 在哪里，理解它负责完成 LibXR 平台初始化和外设封装对象的创建。
- 自己写的部分：
  - 在 app_main.cpp 的 User Code 区域实现过点灯。
  - 在同一位置实现过串口定时发送文本。
这些内容不需要逐条背下来，但要有一个清晰认识：你已经从“完全空白”走到了“能在自己的工程里加一些真实逻辑”。
## 二、通用思路：以后每加一个功能可以先问自己三件事
1. 变化首先发生在什么位置？
- 需要新增 / 修改外设、引脚、中断、时钟？
  - 优先回到 STM32CubeMX 修改 .ioc。
- 是初始化逻辑或“某个外设对象怎么来的”不清楚？
  - 优先看 .config.yaml 和 CodeGenerator 生成的 app_main.cpp。
- 是某个 LibXR 类 / 函数的具体用法不明白？
  - 去 LibXR 文档和 C++ API 参考里查对应的类和成员函数。
2. “自己写的逻辑”应该放在哪里？
- 当前阶段的主要位置就是 app_main.cpp 中的 User Code Begin / End 区域。
- 生成器负责把外设和 LibXR 接好，你在 User Code 区域里只关心“拿到这些对象之后要做什么”。
- 以后再生成代码时，只要逻辑写在 User Code 区域里，就不会被覆盖。
3. 这是“不会用接口”，还是“行为不符合预期”？
- 不会用接口：
  - 先看当前路线对应的任务说明。
  - 再看 LibXR 文档或 API 页面，确认函数签名和参数含义。
- 行为不符合预期（比如灯不闪、串口没输出）：
  - 先检查硬件连接和 CubeMX 配置。
  - 再看 app_main.cpp 里相关外设对象是否正确创建。
  - 最后再看自己写的逻辑是否过于复杂，必要时简化成“只做一件小事”的版本来排查。
## 三、如何查文档和示例（建议形成习惯）
当你遇到“这个名字看着眼熟，但具体怎么用不确定”的情况时，可以按下面的顺序查：
1. 当前路线中的任务页面：
   - 优先看当前小节的任务描述和代码片段，它们通常已经针对新手做了取舍。
   - 如果示例里已经有类似写法，可以先照着跑通，再按需要微调。
2. 官方文档：
   - XRobot / LibXR 文档主页：
     - https://xrobot-org.github.io/
     - https://jiu-xiao.github.io/libxr/
   - 常见查找方式：
     - 按“类别”找：例如 basic_coding/driver/gpio、driver/uart、core-op、core-rw、core-rawdata 等。
     - 按“类名”找：在 API 参考中搜索 STM32GPIO、STM32UART、UART、GPIO 等关键字。
3. GitHub 仓库 README 和示例：
   - LibXR、CodeGenerator、XRobot 的 README：
     - 一般会介绍这个仓库主要负责哪一块工作。
     - 有时会附带最小示例代码或命令行用法。
   - 不需要完整读完，只要抓两点：
     - 这个工具负责哪一层。
     - 有没有和你当前需求类似的简单片段可以直接参考。
4. 报错信息：
   - 优先看第一条错误，不要被整屏红字吓到。
   - 记下其中的函数名、类型名或文件名，这些往往是定位问题的线索。
   - 若看不懂，可以带着关键字回到文档或代码中搜索含义。
## 四、排错时的简单检查顺序
以后遇到问题，可以尝试按下面的顺序简要检查一遍：
1. 硬件和连接：
   - 开发板是否有正常供电，调试器是否连接牢固。
   - 引脚是否和 .ioc 里配置的那几路一致（尤其是 LED、按键、串口）。
2. CubeMX 配置：
   - 对应外设是否启用。
   - 中断 / DMA 是否为该外设打开。
   - 修改后是否重新生成了 STM32 代码。
3. CodeGenerator 和 LibXR：
   - 修改 .ioc 后是否重新运行过代码生成（例如 xr_cubemx_cfg）。
   - 工程是否重新配置 / 编译。
   - app_main.cpp 中是否已经出现对应的 LibXR 封装对象。
4. 自己的代码：
   - 能否先写一个“只做一件事”的版本：
     - 串口只发固定字符串。
     - GPIO 只翻转一次或按固定周期翻转。
   - 确认最小版本能工作后，再往里逐步增加条件和逻辑。
## 五、后面会发生什么（只做心理准备）
在后续的路线中，还会逐步接触：
- 更多外设：例如 ADC、定时器、更多 GPIO 组合。
- 部分中间件：事件、消息、日志等。
- 更复杂一些的应用结构。
但总体上，仍然是在同一条链路上往前走：
- 从 CubeMX 做配置。
- 用 CodeGenerator 生成或更新 LibXR 初始化代码。
- 在 app_main.cpp 的 User Code 区域里，基于已经封装好的对象继续写自己的逻辑。
## 完成标准
- 你能用自己的话说出：
  - STM32CubeMX、CodeGenerator、LibXR、app_main.cpp 中 User Code 各自负责什么。
  - 遇到新需求或错误时，大致会从哪几方面着手排查。
- 你有一个自己认可的“查文档顺序”：先看当前任务 → 再看官方文档 / API → 必要时看 README 和示例。
- 接受这样一件事：后面会有更多外设和中间件加入进来，但思路仍然是沿着同一条链路逐步扩展，而不是推倒重来。
